
_interrupt:

;Robot_main.c,13 :: 		void interrupt(){
;Robot_main.c,14 :: 		if (PIR1.RC1IF == 1) {                        // Do we have uart rx interrupt request?
	BTFSS       PIR1+0, 5 
	GOTO        L_interrupt0
;Robot_main.c,15 :: 		tmp = UART1_Read();                        // Get received byte
	CALL        _UART1_Read+0, 0
	MOVF        R0, 0 
	MOVWF       _tmp+0 
;Robot_main.c,16 :: 		if (tmp == 13) {                         // check for CR
	MOVF        R0, 0 
	XORLW       13
	BTFSS       STATUS+0, 2 
	GOTO        L_interrupt1
;Robot_main.c,17 :: 		txt_Bt[bb] = 0;                            // Puting 0 at the end of the string
	MOVLW       _txt_Bt+0
	ADDWF       _bb+0, 0 
	MOVWF       FSR1 
	MOVLW       hi_addr(_txt_Bt+0)
	ADDWFC      _bb+1, 0 
	MOVWF       FSR1H 
	CLRF        POSTINC1+0 
;Robot_main.c,18 :: 		DataReady = 1;                         // Data is received
	MOVLW       1
	MOVWF       _DataReady+0 
;Robot_main.c,19 :: 		}
	GOTO        L_interrupt2
L_interrupt1:
;Robot_main.c,21 :: 		if (tmp != 10){
	MOVF        _tmp+0, 0 
	XORLW       10
	BTFSC       STATUS+0, 2 
	GOTO        L_interrupt3
;Robot_main.c,22 :: 		txt_Bt[bb] = tmp;                          // Moving the data received from UART to string txt[]
	MOVLW       _txt_Bt+0
	ADDWF       _bb+0, 0 
	MOVWF       FSR1 
	MOVLW       hi_addr(_txt_Bt+0)
	ADDWFC      _bb+1, 0 
	MOVWF       FSR1H 
	MOVF        _tmp+0, 0 
	MOVWF       POSTINC1+0 
;Robot_main.c,23 :: 		bb++;
	INFSNZ      _bb+0, 1 
	INCF        _bb+1, 1 
;Robot_main.c,24 :: 		}
L_interrupt3:
;Robot_main.c,25 :: 		}
L_interrupt2:
;Robot_main.c,26 :: 		PIR1.RC1IF = 0;
	BCF         PIR1+0, 5 
;Robot_main.c,27 :: 		}
L_interrupt0:
;Robot_main.c,29 :: 		if (RC2IF_bit == 1) {             // If interrupt is generated by RCIF
	BTFSS       RC2IF_bit+0, BitPos(RC2IF_bit+0) 
	GOTO        L_interrupt4
;Robot_main.c,30 :: 		txt_GPS[gg] = UART2_Read();         // Read data and store it to txrt string
	MOVLW       _txt_GPS+0
	ADDWF       _gg+0, 0 
	MOVWF       FLOC__interrupt+0 
	MOVLW       hi_addr(_txt_GPS+0)
	ADDWFC      _gg+1, 0 
	MOVWF       FLOC__interrupt+1 
	CALL        _UART2_Read+0, 0
	MOVFF       FLOC__interrupt+0, FSR1
	MOVFF       FLOC__interrupt+1, FSR1H
	MOVF        R0, 0 
	MOVWF       POSTINC1+0 
;Robot_main.c,31 :: 		gg++;                           // Increment string index
	INFSNZ      _gg+0, 1 
	INCF        _gg+1, 1 
;Robot_main.c,32 :: 		if (gg == 768) {                // If index = 768,
	MOVF        _gg+1, 0 
	XORLW       3
	BTFSS       STATUS+0, 2 
	GOTO        L__interrupt10
	MOVLW       0
	XORWF       _gg+0, 0 
L__interrupt10:
	BTFSS       STATUS+0, 2 
	GOTO        L_interrupt5
;Robot_main.c,33 :: 		gg = 0;                       //   set it to zero
	CLRF        _gg+0 
	CLRF        _gg+1 
;Robot_main.c,34 :: 		ready = 1;                     // Ready for parsing GPS data
	MOVLW       1
	MOVWF       _ready+0 
;Robot_main.c,35 :: 		}
L_interrupt5:
;Robot_main.c,36 :: 		RC2IF_bit = 0;                    // Set RCIF to 0
	BCF         RC2IF_bit+0, BitPos(RC2IF_bit+0) 
;Robot_main.c,37 :: 		}
L_interrupt4:
;Robot_main.c,38 :: 		}
L_end_interrupt:
L__interrupt9:
	RETFIE      1
; end of _interrupt

_main:

;Robot_main.c,42 :: 		void main() {
;Robot_main.c,43 :: 		Start_TP();
	CALL        _Start_TP+0, 0
;Robot_main.c,44 :: 		while (1) {
L_main6:
;Robot_main.c,45 :: 		Check_TP();
	CALL        _Check_TP+0, 0
;Robot_main.c,46 :: 		read_uart();
	CALL        _read_uart+0, 0
;Robot_main.c,47 :: 		Check_Joystic();
	CALL        _Check_Joystic+0, 0
;Robot_main.c,48 :: 		}
	GOTO        L_main6
;Robot_main.c,49 :: 		}
L_end_main:
	GOTO        $+0
; end of _main
